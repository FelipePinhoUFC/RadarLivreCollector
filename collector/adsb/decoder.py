from config import COLLECTOR_ID
from math_utils.adsb_decoder_library import *
from math_utils.crc_calc import *

import time

# Aircraft TypeS
cs_tbl = ['@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
          'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', ' ', ' ', ' ', ' ',
          ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
          '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' ', ' ', ' ', ' ', ' ', ' ']

EVEN_PACK = '0'
ODD_PACK = '1'

LAST_ERROR = {"error": None}

# This object is used to receive the Even and Odd packets before complete a final Observation    
class HalfObservation():

    collector = ""

    # Airplane and Route of observed
    airplane = ""
    flight = ""
    
    # Collector position
    latitudeCollector  = 0.0
    longitudeCollector = 0.0
    
    # Airplane position
    latitudeEven  = 0.0
    longitudeEven = 0.0
    latitudeOdd   = 0.0
    longitudeOdd  = 0.0
    altitude      = 0
    
    # Airplane velocity
    verticalVelocity   = 0
    horizontalVelocity = 0
    
    # Airplane angle
    groundTrackHeading = 0
    
    # Observation date time generated by server
    timestamp = 0
    timestampSent = 0
    
    # Originals ADS-B messages
    messageDataId           = ""
    messageDataPositionEven = ""
    messageDataPositionOdd  = ""
    messageDataVelocity     = ""

    # Flags
    lastReceived = ""
    evenReceived = False
    oddReceived = False
    velocityReceived = False
    identityReceived = False
    

    def update(self, other):
        self.timestamp = other.timestamp
        
        if other.evenReceived:
            self.latitudeEven = other.latitudeEven
            self.longitudeEven = other.longitudeEven
            self.altitude = other.altitude
            self.lastReceived = other.lastReceived
            self.evenReceived = True;
            self.messageDataPositionEven = other.messageDataPositionEven
            
                        
        if other.oddReceived:
            self.latitudeOdd = other.latitudeOdd
            self.longitudeOdd = other.longitudeOdd
            self.altitude = other.altitude
            self.lastReceived = other.lastReceived
            self.oddReceived = True;
            self.messageDataPositionOdd = other.messageDataPositionOdd
            
        if other.velocityReceived:
            self.horizontalVelocity = other.horizontalVelocity
            self.verticalVelocity = other.verticalVelocity
            self.groundTrackHeading = other.groundTrackHeading
            self.velocityReceived = True;
            self.messageDataVelocity = other.messageDataVelocity
            
        if other.identityReceived:
            self.airplane = other.airplane
            self.flight = other.flight
            self.identityReceived = True;
            self.messageDataId = other.messageDataId

    def isComplete(self):
        return self.evenReceived and self.oddReceived and self.velocityReceived and self.identityReceived

    def __unicode__(self):
        return "" + str(self.evenReceived) + " : " + str(self.oddReceived) + " : " + str(self.velocityReceived) + " : " + str(self.identityReceived)

class Observation():
    
    # User collector that sent the observation
    collector = COLLECTOR_ID
    
    # Airplane observed
    airplane = ""
    flight = ""
     
    # Airplane position
    latitude  = 0.0
    longitude = 0.0
    altitude  = 0.0
    
    # Airplane velocity
    verticalVelocity = 0.0
    horizontalVelocity = 0.0
     
    #Airplane angle
    groundTrackHeading = 0.0
    
    # Observation date time generated by server
    timestamp      = 0
    timestampSent  = 0
    
    # Originals ADS-B messages
    messageDataId           = ""
    messageDataPositionEven = ""
    messageDataPositionOdd  = ""
    messageDataVelocity     = ""

    def serialize(self):
        return {
            # User collector that sent the observation
            "collector": self.collector, 
            
            # Airplane observed
            "modeSCode": self.airplane,
            "callsign": self.flight,
             
            # Airplane position
            "latitude": self.latitude, 
            "longitude": self.longitude, 
            "altitude": self.altitude, 
            
            # Airplane velocity
            "verticalVelocity": self.verticalVelocity, 
            "horizontalVelocity": self.horizontalVelocity, 
             
            #Airplane angle
            "groundTrackHeading": self.groundTrackHeading, 
            
            # Observation date time generated by server
            "timestamp": int(self.timestamp),
            "timestampSent": int(self.timestampSent),
            
            # Originals ADS-B messages
            "messageDataId": self.messageDataId, 
            "messageDataPositionEven": self.messageDataPositionEven, 
            "messageDataPositionOdd": self.messageDataPositionOdd, 
            "messageDataVelocity": self.messageDataVelocity 
        }


# Receive an ADS-B message and return a HalfObservation object 
def decodeMessage(adsbMessage):
    data = adsbMessage["data"]
    
    latHome = adsbMessage["latitude"]
    lonHome = adsbMessage["longitude"]

    if len(data) == 28:
        if parity112(data) == False:
            
            # CRC invalido
            LAST_ERROR["error"] = "Invalid CRC!"
            return None
        
        # CRC valido
        
        ICAO = data[2:8] #Da pra reduzir
        DFCA = toHex(data[:2]) #Da pra reduzir
        DF = full_bit_zero(bin(eval(DFCA)))[:5] #Da pra reduzir
        DF = eval("0b" + DF) #Da pra reduzir
        CA = full_bit_zero(bin(eval(DFCA)))[5:] #Da pra reduzir
        b_TC = full_bit_zero(bin(eval(toHex(data[8]+data[9]))))[:5] #Da pra reduzir
        TC = eval("0b" + b_TC)  #Da pra reduzir
        b_Mode = full_bit_zero(bin(eval(toHex(data[8]+data[9]))))[5:] #Tres bits para o mode
      
        if DF == 17:
            # 'Downlink Format: 17 - S Mode'

            if TC >= 1 and TC <= 4:
                # "Type: Airplane Identification Message... (Nome do Voo, Tipo Aeronave)"
                hex_adsb_packet = data[8:] #Da pra reduzir
                bin_adsb_packet = c(hex_adsb_packet[0],hex_adsb_packet[1])+c(hex_adsb_packet[2],hex_adsb_packet[3])+c(hex_adsb_packet[4],hex_adsb_packet[5])+c(hex_adsb_packet[6],hex_adsb_packet[7])+c(hex_adsb_packet[8],hex_adsb_packet[9])+c(hex_adsb_packet[10],hex_adsb_packet[11])+c(hex_adsb_packet[12],hex_adsb_packet[13])
                
                formattypecode = bin_adsb_packet[0] + bin_adsb_packet[1] + bin_adsb_packet[2] + bin_adsb_packet[3] + bin_adsb_packet[4] #Da pra reduzir
                aircrafttype = bin_adsb_packet[5] + bin_adsb_packet[6] + bin_adsb_packet[7] #Da pra reduzir
                char = "" #Da pra reduzir
                char = char + cs_tbl[eval("0b"+bin_adsb_packet[8]+bin_adsb_packet[9]+bin_adsb_packet[10]+bin_adsb_packet[11]+bin_adsb_packet[12]+bin_adsb_packet[13])] #1 #Da pra reduzir
                char = char + cs_tbl[eval("0b"+bin_adsb_packet[14]+bin_adsb_packet[15]+bin_adsb_packet[16]+bin_adsb_packet[17]+bin_adsb_packet[18]+bin_adsb_packet[19])] #2 #Da pra reduzir
                char = char + cs_tbl[eval("0b"+bin_adsb_packet[20]+bin_adsb_packet[21]+bin_adsb_packet[22]+bin_adsb_packet[23]+bin_adsb_packet[24]+bin_adsb_packet[25])] #3 #Da pra reduzir
                char = char + cs_tbl[eval("0b"+bin_adsb_packet[26]+bin_adsb_packet[27]+bin_adsb_packet[28]+bin_adsb_packet[29]+bin_adsb_packet[30]+bin_adsb_packet[31])] #4 #Da pra reduzir
                char = char + cs_tbl[eval("0b"+bin_adsb_packet[32]+bin_adsb_packet[33]+bin_adsb_packet[34]+bin_adsb_packet[35]+bin_adsb_packet[36]+bin_adsb_packet[37])] #5 #Da pra reduzir
                char = char + cs_tbl[eval("0b"+bin_adsb_packet[38]+bin_adsb_packet[39]+bin_adsb_packet[40]+bin_adsb_packet[41]+bin_adsb_packet[42]+bin_adsb_packet[43])] #6 #Da pra reduzir
                char = char + cs_tbl[eval("0b"+bin_adsb_packet[44]+bin_adsb_packet[45]+bin_adsb_packet[46]+bin_adsb_packet[47]+bin_adsb_packet[48]+bin_adsb_packet[49])] #7 #Da pra reduzir
                char = char + cs_tbl[eval("0b"+bin_adsb_packet[50]+bin_adsb_packet[51]+bin_adsb_packet[52]+bin_adsb_packet[53]+bin_adsb_packet[54]+bin_adsb_packet[55])] #8 #Da pra reduzir
                
                obs = HalfObservation()
                obs.airplane = ICAO
                obs.flight = char
                obs.latitudeCollector = latHome
                obs.longitudeCollector = lonHome
                obs.timestamp = time.time() * 1000
                obs.identityReceived = True
                obs.messageDataId = data
                return obs
       
            elif TC >= 9 and TC <= 18: 
                # "Type: Airborne Position message... (Altitude, Latitude e Longitude) - Altitude Barometrica"
                hex_adsb_packet = data[8:] #Da pra reduzir
                bin_adsb_packet = c(hex_adsb_packet[0],hex_adsb_packet[1])+c(hex_adsb_packet[2],hex_adsb_packet[3])+c(hex_adsb_packet[4],hex_adsb_packet[5])+c(hex_adsb_packet[6],hex_adsb_packet[7])+c(hex_adsb_packet[8],hex_adsb_packet[9])+c(hex_adsb_packet[10],hex_adsb_packet[11])+c(hex_adsb_packet[12],hex_adsb_packet[13])
                Altitude = "0b" + bin_adsb_packet[8:][:12] #Da pra reduzir
                Latitude = eval("0b" + bin_adsb_packet[22:][:17]) #Da pra reduzir   
                Longitude =  eval("0b" + bin_adsb_packet[-17:]) #Da pra reduzir
                T = bin_adsb_packet[20:][0] #Da pra reduzir
                F = bin_adsb_packet[21:][0] #Da pra reduzir

                Altitude = Altitude[2:][:12] #Da pra reduzir
                bits = Altitude[0]+Altitude[1]+Altitude[2]+Altitude[3]+ Altitude[4]+Altitude[5]+Altitude[6]+Altitude[8]+Altitude[9]+Altitude[10]+Altitude[11] #Da pra reduzir
                oitavo_bit = Altitude[7] #Da pra reduzir
                Altitude = 25 * eval("0b"+bits) - 1000 #Da pra reduzir
                # "Altitude: " + str(Altitude)
               
                if F == EVEN_PACK:
                    # Even Packet
                    obs = HalfObservation()
                    obs.airplane = ICAO
                    obs.latitudeCollector = latHome
                    obs.longitudeCollector = lonHome
                    obs.lastReceived = EVEN_PACK
                    obs.evenReceived = True
                    obs.latitudeEven = Latitude
                    obs.longitudeEven = Longitude
                    obs.altitude = Altitude
                    obs.timestamp = time.time() * 1000
                    obs.messageDataPositionEven = data
                    return obs
                    # UpdateAirplanePosition_T0(ICAO, [Latitude, Longitude, Altitude])
                    
                elif F == ODD_PACK:
                    # Odd Packet
                    
                    obs = HalfObservation()
                    obs.airplane = ICAO
                    obs.latitudeCollector = latHome
                    obs.longitudeCollector = lonHome
                    obs.lastReceived = ODD_PACK
                    obs.oddReceived = True
                    obs.latitudeOdd = Latitude
                    obs.longitudeOdd = Longitude
                    obs.altitude = Altitude
                    obs.timestamp = time.time() * 1000
                    obs.messageDataPositionOdd = data
                    return obs
                    
                    # UpdateAirplanePosition_T1(ICAO, [Latitude, Longitude, Altitude])

                                          
            elif TC == 19:
                # "Type: Airborne Velocity Message... (Ground Speed, Track, Vertical)"
                hex_adsb_packet = data[8:] #Da pra reduzir
                hex_adsb_packet = hex_adsb_packet[:14] #Da pra reduzir
                bin_adsb_packet = c(hex_adsb_packet[0],hex_adsb_packet[1])+c(hex_adsb_packet[2],hex_adsb_packet[3])+c(hex_adsb_packet[4],hex_adsb_packet[5])+c(hex_adsb_packet[6],hex_adsb_packet[7])+c(hex_adsb_packet[8],hex_adsb_packet[9])+c(hex_adsb_packet[10],hex_adsb_packet[11])+c(hex_adsb_packet[12],hex_adsb_packet[13]) #Da pra reduzir
                subtype = eval("0b"+bin_adsb_packet[5] + bin_adsb_packet[6] + bin_adsb_packet[7]) #Da pra reduzir

                if subtype == 0:
                    pass
                    # "Velocidade: Supersonica... Corre cumpadi"
                
                if subtype == 1: # Velocidade (de Ground) nao supersonica
                    # "Velocidade: Nao-Supersonica"
                    directionBitEastWest = bin_adsb_packet[13]
                    directionBitNorthSouth = bin_adsb_packet[24]

                    numEastWest = eval("0b"+bin_adsb_packet[14]+bin_adsb_packet[15]+bin_adsb_packet[16]+bin_adsb_packet[17]+bin_adsb_packet[18]+bin_adsb_packet[19]+bin_adsb_packet[20]+bin_adsb_packet[21]+bin_adsb_packet[22]+bin_adsb_packet[23]) #Da pra reduzir
                    numNorthSouth = eval("0b"+bin_adsb_packet[25]+bin_adsb_packet[26]+bin_adsb_packet[27]+bin_adsb_packet[28]+bin_adsb_packet[29]+bin_adsb_packet[30]+bin_adsb_packet[31]+bin_adsb_packet[32]+bin_adsb_packet[33]+bin_adsb_packet[34]) #Da pra reduzir

                    gnd_spd = math.floor(math.sqrt(numEastWest * numEastWest + numNorthSouth * numNorthSouth))
            
                    if (numEastWest == 0) and (numNorthSouth == 0):
                        return None
                    else:
                        directionBitEastWest = float(directionBitEastWest)
                        directionBitNorthSouth = float(directionBitNorthSouth)
                        numEastWest = float(numEastWest)
                        numNorthSouth = float(numNorthSouth)

                        trk = 0
                        if directionBitEastWest == 0 and directionBitNorthSouth == 0:
                            if numEastWest == 0:
                                trk = 0
                            else:
                                trk = 90 - 180./math.pi*math.atan(numNorthSouth / numEastWest)
                        
                        if directionBitEastWest == 0 and directionBitNorthSouth == 1:
                            if numEastWest == 0:
                                trk = 180
                            else:
                                trk = 90 + 180./math.pi*math.atan(numNorthSouth / numEastWest)

                        if directionBitEastWest == 1 and directionBitNorthSouth == 1:
                            if numEastWest == 0:
                                trk = 180
                            else:
                                trk = 270 - 180./math.pi*math.atan(numNorthSouth / numEastWest)

                        if directionBitEastWest == 1 and directionBitNorthSouth== 0:
                            if numEastWest == 0:
                                trk = 0
                            else:
                                trk = 270 + 180./math.pi*math.atan(numNorthSouth / numEastWest)
                            
                        if (trk - int(math.floor(trk))) < 0.5:
                            trk = int(math.floor(trk))
                        else:
                            trk = int(math.ceil(trk))
                                    
                        obs = HalfObservation()
                        obs.airplane = ICAO
                        obs.latitudeCollector = latHome
                        obs.longitudeCollector = lonHome
                        obs.velocityReceived = True
                        obs.groundTrackHeading = trk
                        obs.horizontalVelocity = gnd_spd
                        obs.verticalVelocity = 0
                        obs.timestamp = time.time() * 1000
                        obs.messageDataVelocity = data
                        return obs
                
            else:
                LAST_ERROR["error"] = "Unknow type code!"
                return None
                # 'Downlink Format: ' +str(DF) + ' Type Code:'+ str(TC) +' - Desconhecido'
                # ServerReport.report('PyAdsbDecoderDataBase', '1', 'Downlink Format/type code: ' +str(DF)+"/" + str(TC) + ' - Desconhecido - '+ data)

    else:
        LAST_ERROR["error"] = str("Invalid package size! " + str(data) + " " + str(len(data)))
        return None
        # 'Tamanho de invalido do pacote...'
        # ServerReport.report('PyAdsbDecoderDataBase', '1', 'Tamanho de invalido do pacote - '+ data)

    
def fromHalfObservation(halfObservation):
    Airplanes1 = int(halfObservation.latitudeEven)
    Airplanes2 = int(halfObservation.latitudeOdd)
    Airplanes3 = int(halfObservation.longitudeEven)
    Airplanes4 = int(halfObservation.longitudeOdd)
    j = math.floor((59. * Airplanes1 - 60. * Airplanes2) / 131072. + 0.5)
    rlat0 = 6. * (modulo(j, 60.) + Airplanes1 / 131072.)
    rlat1 = 6.101694915254237288 * (modulo(j, 59.) + Airplanes2 / 131072.)
   
    if rlat0 > 270:
        rlat0 = rlat0 - 360
    if rlat1 > 270:
        rlat1 = rlat1 - 360

    NL0 = NL(rlat0)
    NL1 = NL(rlat1)
                                           
    if NL0 != NL1:
        # print "Returning null 0" 
        return None

    m = math.floor((Airplanes3 * (NL0 - 1) - Airplanes4 * NL1) / 131072. + 0.5);

    if halfObservation.lastReceived == EVEN_PACK:
        Latitude = rlat0
       
        if NL0 > 1:
            ni = NL0
        else:
            ni = 1
       
        dlon = 360. / ni
        rlon = dlon * (modulo(m, ni) + Airplanes3 / 131072.)
        Longitude = rlon

        if distance(Latitude, Longitude, float(halfObservation.latitudeCollector), float(halfObservation.longitudeCollector)) > 440:
            # print "Pacote Rejeitado - Distancia Muito longa.[", halfObservation.latitudeCollector, halfObservation.longitudeCollector, "] : [", Latitude, Longitude, "]" 
            # print "Returning null 1"
            return None

        now = time.time() * 1000

        obs = Observation()
        obs.airplane = halfObservation.airplane
        obs.flight = halfObservation.flight
        obs.latitude = Latitude
        obs.longitude = Longitude
        obs.altitude = halfObservation.altitude
        obs.verticalVelocity = halfObservation.verticalVelocity
        obs.horizontalVelocity = halfObservation.horizontalVelocity
        obs.groundTrackHeading = halfObservation.groundTrackHeading
        obs.timestamp = halfObservation.timestamp
        obs.timestampSent = halfObservation.timestampSent
        obs.messageDataId           = halfObservation.messageDataId
        obs.messageDataPositionEven = halfObservation.messageDataPositionEven
        obs.messageDataPositionOdd  = halfObservation.messageDataPositionOdd
        obs.messageDataVelocity     = halfObservation.messageDataVelocity
        
        return obs
       
    elif halfObservation.lastReceived == ODD_PACK:
        Latitude = rlat1
       
        if (NL1 - 1) > 1:
            ni = (NL1 - 1)
        else:
            ni = 1
       
        dlon = 360. / ni
        rlon = dlon * (modulo(m, ni) + Airplanes4 / 131072.)
        Longitude = rlon

        if distance(Latitude, Longitude, float(halfObservation.latitudeCollector), float(halfObservation.longitudeCollector)) > 440:
            # print "Pacote Rejeitado - Distancia Muito longa.[", halfObservation.latitudeCollector, halfObservation.longitudeCollector, "] : [", Latitude, Longitude, "]"
            # print "Returning null 2"
            return None

        now = time.time() * 1000

        obs = Observation()
        obs.airplane = halfObservation.airplane
        obs.flight = halfObservation.flight
        obs.latitude = Latitude
        obs.longitude = Longitude
        obs.altitude = halfObservation.altitude
        obs.verticalVelocity = halfObservation.verticalVelocity
        obs.horizontalVelocity = halfObservation.horizontalVelocity
        obs.groundTrackHeading = halfObservation.groundTrackHeading
        obs.timestamp = halfObservation.timestamp
        obs.timestampSent = halfObservation.timestampSent
        obs.messageDataId           = halfObservation.messageDataId
        obs.messageDataPositionEven = halfObservation.messageDataPositionEven
        obs.messageDataPositionOdd  = halfObservation.messageDataPositionOdd
        obs.messageDataVelocity     = halfObservation.messageDataVelocity
        
        return obs
    
    # print halfObservation.lastReceived